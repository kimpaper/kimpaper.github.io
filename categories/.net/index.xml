<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>.NET on 기록 저장소</title>
    <link>https://kimpaper.github.io/categories/.net/</link>
    <description>Recent content in .NET on 기록 저장소</description>
    <image>
      <url>https://kimpaper.github.io/papermod-cover.png</url>
      <link>https://kimpaper.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Oct 2015 12:13:00 +0000</lastBuildDate><atom:link href="https://kimpaper.github.io/categories/.net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>c# 에서 c&#43;&#43;(dll)로 LPCTSTR parameter 넘겨 호출 하기</title>
      <link>https://kimpaper.github.io/2015/10/15/csharp-lpcstr-parameter-call/</link>
      <pubDate>Thu, 15 Oct 2015 12:13:00 +0000</pubDate>
      
      <guid>https://kimpaper.github.io/2015/10/15/csharp-lpcstr-parameter-call/</guid>
      <description>c++ 로 된 dll을 c#에서 호출할때 예제입니다.
먼저 c++ 코드들을 간단히 짰습니다. test.h 1 extern &amp;#34;C&amp;#34; __declspec(dllexport) int test(LPCTSTR szFileName); test.cpp 1 2 3 int test(LPCTSTR szFileName) { return 0; } 다음은 c#쪽 코드들입니다 1 2 3 4 5 6 7 8 9 [DllImport(&amp;#34;sampleLib.dll&amp;#34;, CallingConvention = CallingConvention.Cdecl)] private static extern int test( [MarshalAs(UnmanagedType.LPWStr)] string szFileName); private void button2_Click(object sender, EventArgs e) { string szFileName = @&amp;#34;c:\filename.txt&amp;#34;; int result = test(ticketName); Debug.</description>
    </item>
    
    <item>
      <title>WPF(c#)에서 control을 png로 저장</title>
      <link>https://kimpaper.github.io/posts/dotnet/2015-10-16-wpf-control-save-to-png/</link>
      <pubDate>Thu, 15 Oct 2015 12:13:00 +0000</pubDate>
      
      <guid>https://kimpaper.github.io/posts/dotnet/2015-10-16-wpf-control-save-to-png/</guid>
      <description>예전에 했던 대로 System.Drawing 을 써서 하려고 했는데.. wpf에 이런 기능이 있었네..
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // uiPage.ren public void DoPageToPng(string fileName) { RenderTargetBitmap rtb = new RenderTargetBitmap((int)uiPage.ActualWidth, (int)uiPage.ActualHeight, 96, 96, PixelFormats.Pbgra32); rtb.Render(uiPage); PngBitmapEncoder png2 = new PngBitmapEncoder(); png2.Frames.Add(BitmapFrame.Create(rtb)); using (MemoryStream stream = new MemoryStream()) { png2.Save(stream); using (System.Drawing.Image image = System.Drawing.Image.FromStream(stream)) { image.Save(fileName); } } } </description>
    </item>
    
    <item>
      <title>.NET Framework 4.5.2로 개발했다가. 4.0로... 내림 </title>
      <link>https://kimpaper.github.io/posts/dotnet/2015-09-17-net-framework-452-40/</link>
      <pubDate>Wed, 16 Sep 2015 20:21:00 +0000</pubDate>
      
      <guid>https://kimpaper.github.io/posts/dotnet/2015-09-17-net-framework-452-40/</guid>
      <description>최근에 윈도우 어플을 개발할 일이 생겼다.
.NET 4.5부터 async 문법이 새로 들어갔다 해서.. 이왕 하는거 4.5.2로&amp;hellip; 만들기로 했다. 오&amp;hellip;&amp;hellip; 엄청나게 편리하다.!!
async, await 두개가 중요하다. 특히 UI프로그램에서 background thread와 main thread와의 동기화를 쉽게 지원한다.
아래는 id/pwd를 입력받아서 서버통신으로 인증을 진행하는 코드다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private async void btnLogin_Click(object sender, RoutedEventArgs e) { string id = tbEmail.</description>
    </item>
    
  </channel>
</rss>
